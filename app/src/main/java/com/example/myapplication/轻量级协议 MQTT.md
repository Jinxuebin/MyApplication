  ## 前置知识

（1）什么是 `MQTT` 

`MQTT` （ `Message Queuing Telemetry Transport` ，消息队列遥测传输）是一种基于 `TCP/IP` 协议族的应用层协议

`MQTT` 协议是专门针对硬件性能低下 `&` 网络状况不稳定的场景设计的，这使得 `MQTT` 在物联网和移动应用等受限场景得到广泛应用

（2）`CONNECT` 请求连接

（3）`CONNACK` 确认连接

（2）和（3）等概念词请参考大佬的文章： [为什么每份 Android 简历都说 “熟悉 MQTT 协议”？ - 掘金 (juejin.cn)](https://juejin.cn/post/6984379979962253342#heading-9)



## 服务端搭建（未使用）

因为界面比较难用，推荐跳过，使用下面那个支持简体中文的服务端面板

### 创建 `Broker` 代理节点

`Broker` 相当于服务端

从 [ActiveMQ (apache.org)](https://activemq.apache.org/) 下载解压

![image-20220330105626132](http://cdn.ming3.top/qiniu/202203301056247.png)

解压运行后进入 `bin` 目录，进入 `cmd` 命令框（先查看一下有啥指令）：

![image-20220330105741590](http://cdn.ming3.top/qiniu/202203301057621.png)

可以看到  `create` 指令可以创建一个 `broker` 节点

所以创建一个名字为 `mybroker` 的节点试试看：

```
artemis create myborker
```

然后输入账号密码（这里输入的是 `ming3` 和 `123456`）

确认是否允许匿名访问

等待创建成功（创建成功会在本地生成一个刚才命名的 `myborker` 文件夹）

![image-20220330110041334](http://cdn.ming3.top/qiniu/202203301100363.png)



### 运行

进入 `mybroker` 下的 `bin` 目录，然后执行 `run` 命令

例如： 

```
artemis.cmd run
```

看到以下输出执行成功：

![image-20220330110401353](http://cdn.ming3.top/qiniu/202203301104437.png)

看了下输出，发现 `broker` 运行在本地的 8161 端口，查看下运行了没：

![image-20220330110617248](http://cdn.ming3.top/qiniu/202203301106292.png)

再点击第一个进入控制台并输入刚刚的账号密码登录就可以看到界面了：

![image-20220330140256779](http://cdn.ming3.top/qiniu/202203301402879.png)

### 空白页面处理

发现是个空白界面，这时候就需要回到 `etc` 下修改 `jolokia-access.xml` 文件，在 `<allow-origin>*://yourIPorHostname</allow-origin>` 中输入控制台地址

或者直接禁用检查：

```xml
<cors>
    <!-- Allow cross origin access from localhost ... -->
    <allow-origin>*://127.0.0.1:8161*</allow-origin>


    <!-- Options from this point on are auto-generated by Create.java from the Artemis CLI -->
    <!-- Check for the proper origin on the server side, too -->
    <strict-checking/>
</cors>
```

参考链接：[ActiveMQ Artemis Web控制台未 showing -编程技术网-软件工程师之家 (editcode.net)](https://www.editcode.net/ask/177645)



## 服务端搭建二

上面那个不是很好用的亚子（可能是因为我太菜），换一个换一个：



（1）下载 `MQTT` 服务器 [EMQX: 开源云原生物联网 MQTT 服务器](https://www.emqx.io/zh)

（选择 `windows` 下载即可，这里下载的是 `emqx-4.4.2-otp24.2.1-windows-amd64.zip` ）



（2）解压安装包，进入 `bin` 目录下启动 `cmd` 命令行：命令可以查看：[基本命令 | EMQX 文档](https://www.emqx.io/docs/zh/v4.4/getting-started/command-line.html)

输入以下命令启动服务端

![image-20220406092725136](http://cdn.ming3.top/qiniu/202204060927175.png)



（3）进入管理页面 `127.0.0.1:18083`

账密初始是：`admin` 和 `public`

就进入控制台啦

![image-20220406092953012](http://cdn.ming3.top/qiniu/202204060929099.png)



客户端的使用可以自己代码实现，也可以下载带有 `GUI` 的客户端，这边两个都搞一下，用它俩来通信试试

## 客户端下载

[MQTT X：跨平台 MQTT 5.0 桌面客户端工具](https://mqttx.app/zh)

安装一下即可使用，参考：

![image-20220406105538067](http://cdn.ming3.top/qiniu/202204061055132.png)



## `Android` 端实现

虽然 `eclipse` 的 `MQTT` 项目已经一年多没维护了。。但是这里还是使用它 [eclipse/paho.mqtt.android: MQTT Android (github.com)](https://github.com/eclipse/paho.mqtt.android)

或者可以使用其他的开源项目，[相关链接](https://github.com/hannesa2/paho.mqtt.android)

引入相关依赖：

```groovy
repositories {
    maven {
        url "https://repo.eclipse.org/content/repositories/paho-snapshots/"
    }
}
```

```groovy
dependencies {
    // Eclipse MQTT：https://github.com/eclipse/paho.mqtt.android
    implementation 'org.eclipse.paho:org.eclipse.paho.client.mqttv3:1.1.0'
    implementation 'org.eclipse.paho:org.eclipse.paho.android.service:1.1.1'
    // Androidx 需要加上这个来寻找本地广播服务：https://www.cnblogs.com/jqnl/p/12660824.html
    implementation 'androidx.legacy:legacy-support-v4:1.0.0'
}
```

添加权限：

```xml
<uses-permission android:name="android.permission.INTERNET" />
<uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
<uses-permission android:name="android.permission.WAKE_LOCK" />
```

添加服务：

```xml
<service android:name="org.eclipse.paho.android.service.MqttService" /> <!--MqttService-->
<service android:name="com.example.test.services.MyMqttService" /> <!--MyMqttService-->
```

具体代码逻辑：

```Java
public class MyMqttService extends Service {

    public final String TAG = "MyMqttService";

    // 请求客户端和配置类
    private static MqttAndroidClient mqttAndroidClient;
    private MqttConnectOptions mMqttConnectOptions;

    // 一些设置信息
    public String HOST = "tcp://192.168.1.101:1883"; // 模拟器上写 127.0.0.1 会当作自身，所以要直接写主机的 ip 地址
    public String USERNAME = "ymk_android"; // 用户名
    public String PASSWORD = "123456"; // 密码
    public static String PUBLISH_TOPIC = "publish"; // 发布主题
    public static String RESPONSE_TOPIC = "response"; // 响应主题
    // @RequiresApi(api = 26)
    // public String CLIENTSIDE = Build.VERSION.SDK_INT >= Build.VERSION_CODES.O ? Build.getSerial() : Build.SERIAL;//客户端ID，一般以客户端唯一标识符表示，这里用设备序列号表示
    public String CLIENTSIDE = "test2";

    // 开启服务
    public static void startService(Context context) {
        context.startService(new Intent(context, MyMqttService.class));
    }

    // 服务入口，通过 init 方法初始化一系列参数
    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        init();
        return super.onStartCommand(intent, flags, startId);
    }

    // 初始化
    private void init() {
        // 服务器地址（协议+地址+端口号）
        String serverURI = HOST;
        // 创建客户端传入三个参数：context、服务器地址、客户端唯一Id
        mqttAndroidClient = new MqttAndroidClient(this, serverURI, CLIENTSIDE);
        // 设置监听订阅消息的回调
        mqttAndroidClient.setCallback(mqttCallback);
        // 创建配置类
        mMqttConnectOptions = new MqttConnectOptions();
        // 设置是否清除缓存
        mMqttConnectOptions.setCleanSession(true);
        // 设置超时时间，单位：秒
        mMqttConnectOptions.setConnectionTimeout(10);
        // 设置心跳包发送间隔，单位：秒
        mMqttConnectOptions.setKeepAliveInterval(20);
        // 设置用户名
        mMqttConnectOptions.setUserName(USERNAME);
        // 设置密码
        mMqttConnectOptions.setPassword(PASSWORD.toCharArray());

        // 设置 last will message 遗嘱消息
        boolean doConnect = true;
        String message = "{\"terminal_uid\":\"" + CLIENTSIDE + "\"}";
        try {
            mMqttConnectOptions.setWill(PUBLISH_TOPIC, message.getBytes(), 2, false);
        } catch (Exception e) {
            Log.i(TAG, "出错了", e);
            doConnect = false;
            iMqttActionListener.onFailure(null, e);
        }

        // 连接
        if (doConnect) {
            doClientConnection();
        }
    }

    /**
     * 连接MQTT服务器
     */
    private void doClientConnection() {
        if (!mqttAndroidClient.isConnected() && isConnectIsNormal()) {
            try {
                mqttAndroidClient.connect(mMqttConnectOptions, null, iMqttActionListener);
            } catch (MqttException e) {
                e.printStackTrace();
            }
        }
    }

    /**
     * 发布 （模拟其他客户端发布消息）
     *
     * @param message 消息
     */
    public static void publish(String message) {
        try {
            // 参数分别为：主题、消息的字节数组、服务质量、是否在服务器保留断开连接后的最后一条消息
            mqttAndroidClient.publish(PUBLISH_TOPIC, message.getBytes(), 2, false);
        } catch (MqttException e) {
            e.printStackTrace();
        }
    }

    /**
     * 响应 （收到其他客户端的消息后，响应给对方告知消息已到达或者消息有问题等）
     *
     * @param message 消息
     */
    public void response(String message) {
        try {
            // 参数分别为：主题、消息的字节数组、服务质量、是否在服务器保留断开连接后的最后一条消息
            mqttAndroidClient.publish(RESPONSE_TOPIC, message.getBytes(), 2, false);
        } catch (MqttException e) {
            e.printStackTrace();
        }
    }

    /**
     * 判断网络是否连接
     */
    private boolean isConnectIsNormal() {
        ConnectivityManager connectivityManager = (ConnectivityManager) this.getApplicationContext().getSystemService(Context.CONNECTIVITY_SERVICE);
        NetworkInfo info = connectivityManager.getActiveNetworkInfo();
        if (info != null && info.isAvailable()) {
            String name = info.getTypeName();
            Log.i(TAG, "当前网络名称：" + name);
            return true;
        } else {
            Log.i(TAG, "没有可用网络");
            /*没有可用网络的时候，延迟3秒再尝试重连*/
            new Handler().postDelayed(new Runnable() {
                @Override
                public void run() {
                    doClientConnection();
                }
            }, 3000);
            return false;
        }
    }

    @Nullable
    @Override
    public IBinder onBind(Intent intent) {
        return null;
    }

    @Override
    public void onDestroy() {
        // 断开连接
        try {
            mqttAndroidClient.disconnect();
        } catch (MqttException e) {
            e.printStackTrace();
        }
        super.onDestroy();
    }

    // MQTT是否连接成功的监听
    private IMqttActionListener iMqttActionListener = new IMqttActionListener() {

        @Override
        public void onSuccess(IMqttToken arg0) {
            Log.i(TAG, "连接成功 ");
            try {
                // 订阅主题，参数：主题、服务质量
                mqttAndroidClient.subscribe(PUBLISH_TOPIC, 2);
            } catch (MqttException e) {
                e.printStackTrace();
            }
        }

        @Override
        public void onFailure(IMqttToken arg0, Throwable arg1) {
            arg1.printStackTrace();
            Log.i(TAG, "连接失败 ");
            // 连接失败，重连（可关闭服务器进行模拟）
            doClientConnection();
        }
    };

    // 订阅主题的回调
    private MqttCallback mqttCallback = new MqttCallback() {

        @Override
        public void messageArrived(String topic, MqttMessage message) {
            Log.i(TAG, "收到消息： " + new String(message.getPayload()));
            // 收到消息，这里弹出Toast表示。如果需要更新UI，可以使用广播或者EventBus进行发送
            Toast.makeText(getApplicationContext(), "messageArrived: " + new String(message.getPayload()), Toast.LENGTH_LONG).show();
            // 收到其他客户端的消息后，响应给对方告知消息已到达或者消息有问题等
            response("message arrived");
        }

        @Override
        public void deliveryComplete(IMqttDeliveryToken arg0) {

        }

        @Override
        public void connectionLost(Throwable arg0) {
            // 连接断开，重连
            Log.i(TAG, "连接断开 ");
            // doClientConnection();
        }
    };
}
```



## 测试

在活动中启动服务，测试是否可以接收到订阅了：

先看看服务端：

![image-20220406141652971](http://cdn.ming3.top/qiniu/202204061416047.png)

再测试 `GUI` 发布事件：

![image-20220406141833873](http://cdn.ming3.top/qiniu/202204061418925.png)

点击发送，发现可以了：

![image-20220406141914912](http://cdn.ming3.top/qiniu/202204061419029.png)



## 参考链接

原理：[为什么每份 Android 简历都说 “熟悉 MQTT 协议”？ - 掘金 (juejin.cn)](https://juejin.cn/post/6984379979962253342#heading-45)

文章：[Android安卓使用mqtt推送消息，实现mqtt客户端 - 明月心~ - 博客园 (cnblogs.com)](https://www.cnblogs.com/muphy/p/14702211.html)

[Android消息推送MQTT实战 (qq.com)](https://mp.weixin.qq.com/s/Usk9tEIN5zKVlmYnXkzrLw)

[Android APP必备高级功能，消息推送之MQTT_一口仨馍的博客-CSDN博客_mqtt安卓app](https://blog.csdn.net/qq_17250009/article/details/52774472)

[一步一步来：MQTT服务器搭建、MQTT客户端使用_IT-Warehouse的博客-CSDN博客_mqtt服务器搭建](https://blog.csdn.net/yufm/article/details/107059233)





